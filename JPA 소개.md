# 📌 목차
+ SQL 중심적인 개발의 문제점
+ JPA 소개

## 객체와 RDB 
보통 객체지향적으로 개발하게 된다. <br>
그런데 DB 세계는 모통 RDB(Oracle, MongoDB)를 쓰게 된다. <br>
지금 객체를 RDB에 관리하는 시대다. <br>
그런데 `객체를 RDB에 보관`하기 위해 `반복전인 SQL`을 사용해야 한다.  <br>

## SQL 중심적인 개발의 문제점
(자바객체 -> SQL) (SQL -> 자바객체로) 무한 반복 CRUD 쿼리를 작성해야 한다. <br>
#### 예를 들어 member 객체를 저장할 때
```
INSERT INTO MEMBER(MEMBER_ID, NAME, TEL) VALUES
SELECT MEMBER_ID, NAME, TEL FROM MEMBER M
```
문제는 필드만 추가해도,  <br> SQL을 처음부터 작성해야 하고 중간중간 오류가 생길 위험이 많다.

### 패러다임 불일치
객체지향 프로그래밍은 '추상화/캡슐화/정보은닉/상속/다형성' 시스템의 복잡성을 제어할 수 있는 다양한 장치를 제공한다. <br>
+ `1` 객체를 영구 보관하는 다양한 저장소(RDB, NoSQL, File, OODB)중 아무거나 골라 넣어도 된다.
+ `2` 그런데, "현실적인 대안은 RDB"를 선택할 것이다.
+ `3` 이때 객체를 RDB에 저장할 때, `객체 데이터를 SQL로 바꿔서` RDB에 넣어야 한다.

### 객체와 RDB의 차이
#### 1. 상속
+ 객체 상속관계: 부모를 추상화하여 두고, 그 밑에 자식객체를 둔다.
+ RDB 테이블에서의 관계: (상속개념이 없다.)  부모같은 테이블과 자식같은 테이블을 만들어 (데이터를 분리하고), 필요한 것을 join해서 가져온다.

> 이때 "자식 객체 album을 저장하기 위해서는" 어떤 과정을 거쳐야 하나? <br>
```
1) 객체 분해 (Item- album을 분리한다. -> ALBUM에 필요한 정보를 찾고)
2) SQL 작성 ; INSERT INTO ITEM, INSERT INTO ALBUM
```

> "album을 조회한다면?" - 더 복잡한 작업필요 <br>
```
( 부모객체 Item도 필요하고 Album 객체도 필요하다.) -> 각각 필요한 것을 가져와 조인해야 한다.
1) 각각의 테이블에 따른 조인 SQL 작성해야 한다. 
2) 각각의 객체 생성..
3. 상상만 해도 복잡
4. 더 이상의 설명은 생략한다.
5. 그래서 DB에 저장할 객체에는 상속 관계 안쓴다.
```

> 이 과정 말고, "자바 컬렉션에 저장한다면?"
```
Album album = list.get(albumId); 식으로 간단할 것이다.
```

#### 2. 연관관계
+ 객체는 참조를 사용한다. -> member.getTeam();
+ 그런데 테이블은 외래키를 사용해서 join해야 한다. -> JOIN ON M.TEAM_ID = T.TEAM_ID

> 보통 객체를 테이블에 맞춰 모델링을 많이 한다. <br> 그래야 테이블에 맞춘 객체를 저장할 수 있다.

> 객체다운 모델링을 하면, <br> member.getTeam() 처럼 연관된 팀의 참조를 보관한다. <br>
여기서 member.getTeam.getId()로 외래키를 넣을 수도 있는데 복잡해진다.

> 객체 그래프 탐색, <br>
SQL을 직접 다루면 처음 실행한 SQL에 따라 어디까지 탐색할 수 있는지 정해진다. <br>
처음 조회한 것만 탐색이 가능하다.

> 엔티티 신뢰 문제 <br>
결국 탐색할 수 있는지 알아보기 위해 데이터 접근 계층인 DAO를 열어서 SQL을 직접 확인해야 한다. <br>
그렇다고 모든 객체 그래프를 조회해서 애플리케이션 메모리에 올려두는 건 현실성이 없다.

> 비교하기 <br>
memberId  같은 키값으로 객체를 2번 조회했을 때, ==(동등성) 비교시 "다른객체로 false"ek. <br>
만약 객체를 컬렉션 조회처럼 동작했다면 "비교가 성공이다" -> 이거를 JPA로 해결할 수 있다.


## JPA 소개
> ORM은 객체와 RDB를 매핑한다는 뜻이다. <br> JPA는 애플리케이션과 JDBC 사이에서 동작한다.

### JPA 동작
![JPA 동작원리](https://github.com/Kim-Gyuri/studying_programming_archive/assets/57389368/94153437-a7cd-4b5a-9dbb-427d4b05c995)

#### 예: member객체를 저장할 때
```
1. member객체를 DAO에 넘기고, DAO가 JPA에게 던진다.
2. JPA가 entity를 분석하여 INSERT SQL을 생성해서 DB에 실행한다.
```

#### 예: member객체를 조회할 때
```
1. DAO에 id를 담아 find(id)를 한다.
2. JPA가 SELECT SQL을 생성해서  JDBC를 사용해 RestfulSet 매핑을 하여 조회해준다.
```

### JPA 배경
```
EJB - 엔티티 빈(자바표준) ; 기술도 어렵고 성능이 별로다.
Hibernate(오픈소스) ; EJB에 비해 가볍고 실용적이다. 
JPA (자바표준) ; 오픈소스를 정제한 것
```

### JPA란?
+ 인터페이스를 모아둔 것이다.
+ JPA 구현체로 hibernate, EclipseLink, DataNucleus가 있다.
```
JPA 1.0 : 초기버전, 복합키와 연관관계 기능이 부족하다.
JPA 2.0 : 대부분의 ORM 기능을 포함, JPA Criteria
JPA 2.x : 컨버터, 엔티티 그래프 기능추가
```

### JPA를 왜 사용해야 하는가?
#### 1. SQL 중심적인 개발에서 객체 중심으로 개발할 수 있다. -> 생산성, 유지보수
> 코드를 jpa.persist(member), jpa.find(memberId), member.setName("nn") 으로 CRUD SQL이 DB에 실행된다. <br>
> 유지보수; SQL과 JDBC, API 코드를 JPA가 대신 처리해주므로 코드수가 줄어든다.

#### 2. 패러다임 불일치 해결
JPA는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임 불일치 문제를 해결해준다.

#### 3. 성능
```
1) 같은 트랜잭션 안에서는 같은 엔티티를 반환한다. 
(2번째 조회할 때는 (이전에 조회한 캐싱된) 회원 객체를 재사용한다.)

2) 쓰기 지연
버퍼 라이팅이 가능하다. (JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송할 수 있다.)

3) 지연로딩과 즉시로딩
지연로딩 ; 객체가 실제 사용될 때 로딩된다.
즉시로딩 ; JOIN SQL로 1번에 연관된 객체끼리 미리 조회한다.
```
