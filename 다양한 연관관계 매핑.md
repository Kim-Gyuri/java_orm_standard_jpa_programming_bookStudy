# 목차
[1. 다양성](#1-다양성)<br>
[2. 단방향 양방향](#2-단방향-양방향)<br>
[3. 연관관계의 주인](#3-연관관계의-주인)<br>
[4. 다대일](#4-다대일)<br>
[5. 다대일 단방향](#5-다대일-단방향)<br>
[6. 다대일 양방향](#6-다대일-양방향)<br>
[7. 일대다](#7-일대다)<br>
[8. 일대다 단방향](#8-일대다-단방향)<br>
[9. 일대다 양방향](#9-일대다-양방향)<br>

엔티티의 연관관계를 매핑할 때는 다음 3가지를 고려해야 한다. <br>
+ 다중성
+ 단방향, 양방향
+ 연관관계 주인

> `1` 연관관계가 있는 두 엔티티가 일대일 관계인지 일대다 관계인지 다중성을 고려해야 한다. <br>
>  `2` 두 엔티티 중 한쪽만 참조하는 단방향 관계인지 서로 참조하는 양방향 관계인지 고려해야 한다. <br>
>  `3` 양방향 연관관계의 주인을 정해야 한다. 

## 1. 다중성
연관관계에는 다음과 같은 다중성이 있다.
+ 다대일
+ 일대다
+ 일대일
+ 다대다
> 보통 다대일과 일대다 관계를 가장 많이 사용하고 관계는 실무에서 거의 사용하지 않는다.

## 2. 단방향 양방향
+ 테이블은 왜래키 하나로 조인을 사용해서 양방향으로 쿼리가 가능하다. 
> 사실상 방향이라는 개념이 없다.

> 반면에 객체는 참조용 필드를 가지고 있는 객체만 연관된 객체를 조회할 수 있다. <br>
> 객체 관계에서 한 쪽만 참조하는 것을 단방향 관계라고 하고, 양쪽이 서로 참조하는 것을 양방향 관계라고 한다.

## 3. 연관관계의 주인
+ DB는 외래키 하나로 두 테이블이 연관관계를 맺는다.
+ 따라서 테이블의 연관관계를 관리하는 포인트는 외래 키 하나다.
+ 문제는 두 객체 연관관계를 관리하는 포인트가 2개인 것.
> `객체 연관관계` <br> 엔티티를 양방향으로 매핑하면 A->B, B->A 2곳에서 서로를 참조한다. <br> 따라서 객체의 연관관계를 관리하는 포인트는 2곳이다. 

> JPA는 두 객체 연관관계 중 하나를 정해서 DB 외래키를 관리하는데 이것을 연관관계의 주인인라고 한다. <br>
> 따라서 A->B, B->A 둘 중 하나를 정해서 외래키를 관리해야 한다. <br>
> 연관관계 주인 : 외래 키를 관리하는 참조 <br> 반대편 : mappedBy 속성을 사용하고, 외래키를 변경할 수 없고 읽기만 가능

## 4. 다대일
+ 다대일 관계의 반대방향은 항상 일대다 관계고 일대다 관계의 반대 방향은 항상 다대일 관계다.
+ `외래키는 항상 N쪽에 있다.`
+ 따라서 양방향 관계에서 연관관계의 주인은 항상 다쪽이다.
+ 예를 들어 회원(N)과 팀(1)이 있으면 회원 쪽이 연관관계의 주인이다.

## 5. 다대일 단방향
![다대일 단방향](https://user-images.githubusercontent.com/57389368/186345473-b8293e63-cb1c-4764-b8a3-74e15a819781.JPG) <br>

`회원 엔티티` <br>
```java
@Entity
public class Member {
  
  @Id @GeneratedValue
  @Column(name = "MEMBER_ID")
  private Long id;
  
  private String username;
  
  @ManyToOne                    //(1)
  @JoinColumn(name = "TEAM_ID") //(2)
  private Team team;
  
  //getter, setter
}
```

`팀 엔티티` <br>
```java
@Entity
public class Team {     //(3)
  
  @Id @GeneratedValue
  @Column(name = "TEAM_ID")
  private Long id;
  
  private String name;
  
  //getter, setter
}
```

+ `1` DB입장에서는 TEAM(1), MEMBER(N)이다. 그래서 MEMBER에 외래키가 있다.
+ `2` MEMBER->TEAM을 참조한다면, TEAM_ID를 끌어와서 Member에 'Team team'을 해놓고 매핑걸면된다.
+ `3` Team은 Member로 참조할 의지가 없어서 그냥 이렇게 두면 된다.

> 회원은 Member.team으로 팀 엔티티를 참조할 수 있다. <br> 반대로 팀에는 회원을 참조하는 필드가 없다. <br> 따라서 회원과 팀은 다대일 단방향 연관관계이다.

## 6. 다대일 양방향
![다대일 양방향](https://user-images.githubusercontent.com/57389368/186346484-c3b3589d-961c-4728-ab68-044e08080eb8.JPG) <br>

+ 다대일 양방향의 객체 연관관계에서 실선이 연관관계의 주인이다, Member.team
+ 점선은 연관관계의 주인이 아니다. Team.member

<br>

+ `1` List members를 추가한다. (추가한다고 해서 테이블에 영향이 없다.)
+  왜냐하면, 연관관계 주인은 'Team team'이기 때문에 team으로 관리하고 있기 때문에 반대쪽 List members는 읽기만 한다.

`회원 엔티티` <br>
```java
@Entity
public class Member {
  
  @Id @GeneratedValue
  @Column(name = "MEMBER_ID")
  private Long id;
  
  private String username;
  
  @ManyToOne                   
  @JoinColumn(name = "TEAM_ID")
  private Team team;
  
  //getter, setter
}
```

`팀 엔티티` <br>
```java
@Entity
public class Team {     
  
  @Id @GeneratedValue
  @Column(name = "TEAM_ID")
  private Long id;
  
  private String name;
  
  @OneToMany(mappedBy = "team")  //추가
  private List<Member> members = new ArrayList<Member>();
  
  //getter, setter
}
```

+ 양방향은 외래키가 있는 쪽이 연관관계의 주인이다.
> 일대다와 다대일 연관관계는 항상 다(N)에 외래키가 있다. <br> 여기서는 N쪽인 MEMBER 테이블이 외래키를 가지고 있으므로 Member.team이 연관관계의 주인이다. <br>
> JPA는 외래키를 관리할 때 연관관계의 주인만 사용한다. <br> `주인이 아닌 Team.members는 조회를 위한 JPQL이나 객체그래프를 탐색할 때 사용한다.`

+ 양방향 연관관계는 항상 서로를 참조해야 한다.
> 양방향 연관관계는 항상 서로 참조해야 한다. <br> 어느 한 쪽만 참조하면 양방향 연관관계가 성립하지 않는다. <br> 항상 서로 참조하게 하려면 연관관계 편의 메소드를 작성하는 것이 좋다.
> <br> 편의 메소드를 양쪽에 다 작성하면 무한루프에 빠지므로 주의하자. <br> 무한루프에 빠지지 않도록 검사하는 로직도 있다.



## 7. 일대다
엔티티를 하나 이상 참조할 수 있으므로 자바 컬렉션인 Collection, List, Set, Map 중에 하나를 사용해야 한다.

## 8. 일대다 단반향
![일대다 단방향](https://user-images.githubusercontent.com/57389368/186350662-8df26212-2eef-4eec-a774-714004119a3a.JPG) <br>

+ 일단 이 모델을 권장하지 않는다.
> DB 입장에서는 TEAM이랑  MEMBER에서 N쪽인 MEMBER가 외래키를 가져야 한다. <br> TEAM에 외래키가 있다면 TEAM을 계속 insert해야 하므로 TEAM이 1이 아닌 중복이 되버린다.

+ DB 입장에서는 TEAM이 아닌 MEMBER가 외래키 주인이다.
> Team에 'List members'에 members의 값을 바꿨을 때 뭔가 'TEAM_ID(FK)' 외래키를 업데이트 해줘야 한다. <br>
> 예: Team에서 'List members'가 연관관계 주인이며, 외래키는 MEMBER의 'TEAM_ID(FK)'에 있다.  <br> 'List members'를 추가/변경하려면 MEMBER의 TEAM_ID를 변경해줘야 한다.

`Member 엔티티` <br>
```java
@Entity
public class Member {
  
  @Id @GeneratedValue
  @Column(name = "MEMBER_ID")
  private Long id;
  
  private String username;
  
  //외래키를 매핑할 수 있는 참조 필드가 없다.
  
  //getter, setter
}
```

`Team 엔티티` <br>
```java
@Entity
public class Team {     
  
  @Id @GeneratedValue
  @Column(name = "TEAM_ID")
  private Long id;
  
  private String name;
  
  @OneToMany
  @JoinColumn(name = "TEAM_ID") //MEMBER 테이블의 TEAM_ID (FK)
  private List<Member> members = new ArrayList<Member>();
  
  //getter, setter
}
```

+  일대다 단방향 관계는 약간 특이하다.
+ `1` 팀 엔티티의 Team.members로 회원 테이블의 TEAM_ID 외래키를 관리한다.
+ `2` 보통 자신이 매핑한 테이블의 외래키를 관리하는데, 이 매핑은  반대쪽 테이블에 있는 외래키를 관리한다.
+ `3` 그럴 수밖에 없는 것이 일대다 관계에서 외래키는 항상 다쪽 테이블에 있다.
+ `4` 하지만 다 쪽인 Member 엔티티에는 외래키를 매핑할 수 있는 참조 필드가 없다.
+ `5` 대신에 반대쪽인 Team 엔티티에만 참조 필드인 members가 있다.\
+ `6` 따라서 반대편 테이블의 외래키를 관리하는 특이한 모습이 나타난다.

<br> <br>

+ 일대다 단방향 관계를 매핑할 때는 @JoinColumn을 명시해야 한다.
+ 그렇지 않으면 JPA는 연결 테이블을 중간에 두고 연관관계를 관리하는 조인 테이블 전략을 기본으로 사용해서 매핑해야 한다.
> 조인테이블은 나중에 자세히 알아보자.

### 일대다 단방향 매핑의 문제
```java
public void testSave() {
  
  Member member1 = new Member("member1");
  Member member2 = new Member("member2");
  
  Team team1 = new Team("team1");
  team1.getMembers().add(member1);
  team1.getMembers().add(member2);
  
  em.persist(member1);  //insert member1
  em.persist(member2);  //insert member2
  em.persist(team1);    //insert team1, update member1.fk, update member2.fk
  
  transaction.commit();
}
```  

` 결과창` <br>
```
insert into Member (MEMBER_ID, username) values (null, ?)
insert into Member (MEMBER_ID, username) values (null, ?)
insert into Team (TEAM_ID, name) values (null, ?)
update Member set Team_ID =? where MEMBER_ID=?
update Member set Team_ID =? where MEMBER_ID=?
```

`update Member 쿼리가 나간 이유는?` <br>
+ Member 엔티티는 Team 엔티티를 모른다.
+ 연관관계에 대한 정보는 Team 엔티티의 members가 관리한다.
+ 따라서 Member 엔티티를 저장할 때는 MEMBER 테이블의 TEAM_ID 외래키에 아무값도 저장되지 않는다.
+ 대신 Team 엔티티를 저장할 때 Team.members의 참조값을 확인해서 회원 테이블에 있는 TEAM_ID 외래키를 업데이트한다.

<br> <br>

### 일대다 단방향 정리
+ 일대다 단방향은 (1)쪽이 연관관계 주인이다.
+ 테이블 연관관계에서, 일대다 관계는 항상 (N)쪽이 외래키를 갖는다. (여기서 관계가 틀어진다.)
+ 객체 연관관계와 테이블 연관관계의 차이 때문에, 반대편 테이블의 외래키를 관리하는 특이한 구조다. (패러다임이 다른데, ORM이 억지로 해결하려는 것)
+ JoinColumn을 꼭 써야 한다. (JoinColumn 없이 실행하려면, 중간 테이블을 추가해야 한다.)

### 일대다 단방향의  단점
+ 엔티티가 관리하는 외래키가 다른 테이블에 있다. (엄청난 단점)
+ 연관관계 관리를 위해 추가로 update SQL을 실행한다.
+ `결론, 다대일 양방향 매핑을 사용하자.`

### 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자.
+ 일대다 단방향 매핑을 사용하면 엔티티를 매핑한 테이블이 아닌 다른 테이블의 외래키를 관리해야 한다.
+ 이것은 성능 문제도 있지만 관리도 부담스럽다.
+ 문제를 해결하는 좋은 방법은 다대일 양방향 매핑을 사용하는 것이다.
+ `다대일 양방향 매핑은 관리해야 하는 외래키가 본인 테이블에 있다.`
+ 따라서 일대다 단방향 매핑 같은 문제가 발생하지 않는다.

## 9. 일대다 양방향









