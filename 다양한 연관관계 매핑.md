# 📌 목차
[0. 엔티티의 연관관계를 매핑](#0-엔티티의-연관관계를-매핑)<br>
[1. 다중성](#1-다중성)<br>
[2. 단방향 양방향](#2-단방향-양방향)<br>
[3. 연관관계의 주인](#3-연관관계의-주인)<br>
[4. 다대일](#4-다대일)<br>
[5. 다대일 단방향](#5-다대일-단방향)<br>
[6. 다대일 양방향](#6-다대일-양방향)<br>
[7. 일대다](#7-일대다)<br>
[8. 일대다 단방향](#8-일대다-단방향)<br>
[9. 일대다 양방향](#9-일대다-양방향)<br>
[10. 일대일](#10-일대일)<br>
[11. 주 테이블에 외래키를 둔 일대일 단방향](#11-주-테이블에-외래키를-둔-일대일-단방향)<br>
[12. 주 테이블에 외래키를 둔 일대일 양방향](#12-주-테이블에-외래키를-둔-일대일-양방향)<br>
[13. 대상 테이블에 외래키를 둔 일대일 단방향](#13-대상-테이블에-외래키를-둔-일대일-단방향)<br>
[14. 대상 테이블에 외래키를 둔 일대일 양방향](#14-대상-테이블에-외래키를-둔-일대일-양방향)<br>
[15. 일대일 정리편](#15-일대일-정리편)<br>

## 0. 엔티티의 연관관계를 매핑
엔티티의 연관관계를 매핑할 때는 다음 3가지를 고려해야 한다. <br>
+ 다중성
+ 단방향, 양방향
+ 연관관계 주인

> `1` 연관관계가 있는 두 엔티티가 일대일 관계인지 일대다 관계인지 다중성을 고려해야 한다. <br>
>  `2` 두 엔티티 중 한쪽만 참조하는 단방향 관계인지 서로 참조하는 양방향 관계인지 고려해야 한다. <br>
>  `3` 양방향 연관관계의 주인을 정해야 한다. 

## 1. 다중성
연관관계에는 다음과 같은 다중성이 있다.
+ 다대일
+ 일대다
+ 일대일
+ 다대다
> 보통 다대일과 일대다 관계를 가장 많이 사용하고 관계는 실무에서 거의 사용하지 않는다.

## 2. 단방향 양방향
+ 테이블은 왜래키 하나로 조인을 사용해서 양방향으로 쿼리가 가능하다. 
> 사실상 방향이라는 개념이 없다.

> 반면에 객체는 참조용 필드를 가지고 있는 객체만 연관된 객체를 조회할 수 있다. <br>
> 객체 관계에서 한 쪽만 참조하는 것을 단방향 관계라고 하고, 양쪽이 서로 참조하는 것을 양방향 관계라고 한다.

## 3. 연관관계의 주인
+ DB는 외래키 하나로 두 테이블이 연관관계를 맺는다.
+ 따라서 테이블의 연관관계를 관리하는 포인트는 외래 키 하나다.
+ 문제는 두 객체 연관관계를 관리하는 포인트가 2개인 것.
> `객체 연관관계` <br> 엔티티를 양방향으로 매핑하면 A->B, B->A 2곳에서 서로를 참조한다. <br> 따라서 객체의 연관관계를 관리하는 포인트는 2곳이다. 

> JPA는 두 객체 연관관계 중 하나를 정해서 DB 외래키를 관리하는데 이것을 연관관계의 주인인라고 한다. <br>
> 따라서 A->B, B->A 둘 중 하나를 정해서 외래키를 관리해야 한다. <br>
> 연관관계 주인 : 외래 키를 관리하는 참조 <br> 반대편 : mappedBy 속성을 사용하고, 외래키를 변경할 수 없고 읽기만 가능

## 4. 다대일
+ 다대일 관계의 반대방향은 항상 일대다 관계고 일대다 관계의 반대 방향은 항상 다대일 관계다.
+ `외래키는 항상 N쪽에 있다.`
+ 따라서 양방향 관계에서 연관관계의 주인은 항상 다쪽이다.
+ 예를 들어 회원(N)과 팀(1)이 있으면 회원 쪽이 연관관계의 주인이다.

## 5. 다대일 단방향
![다대일 단방향](https://user-images.githubusercontent.com/57389368/186345473-b8293e63-cb1c-4764-b8a3-74e15a819781.JPG) <br>

`회원 엔티티` <br>
```java
@Entity
public class Member {
  
  @Id @GeneratedValue
  @Column(name = "MEMBER_ID")
  private Long id;
  
  private String username;
  
  @ManyToOne                    //(1)
  @JoinColumn(name = "TEAM_ID") //(2)
  private Team team;
  
  //getter, setter
}
```

`팀 엔티티` <br>
```java
@Entity
public class Team {     //(3)
  
  @Id @GeneratedValue
  @Column(name = "TEAM_ID")
  private Long id;
  
  private String name;
  
  //getter, setter
}
```

+ `1` DB입장에서는 TEAM(1), MEMBER(N)이다. 그래서 MEMBER에 외래키가 있다.
+ `2` MEMBER->TEAM을 참조한다면, TEAM_ID를 끌어와서 Member에 'Team team'을 해놓고 매핑걸면된다.
+ `3` Team은 Member로 참조할 의지가 없어서 그냥 이렇게 두면 된다.

> 회원은 Member.team으로 팀 엔티티를 참조할 수 있다. <br> 반대로 팀에는 회원을 참조하는 필드가 없다. <br> 따라서 회원과 팀은 다대일 단방향 연관관계이다.

## 6. 다대일 양방향
![다대일 양방향](https://user-images.githubusercontent.com/57389368/186346484-c3b3589d-961c-4728-ab68-044e08080eb8.JPG) <br>

+ 다대일 양방향의 객체 연관관계에서 실선이 연관관계의 주인이다, Member.team
+ 점선은 연관관계의 주인이 아니다. Team.member

<br>

+ `1` List members를 추가한다. (추가한다고 해서 테이블에 영향이 없다.)
+  왜냐하면, 연관관계 주인은 'Team team'이기 때문에 team으로 관리하고 있기 때문에 반대쪽 List members는 읽기만 한다.

`회원 엔티티` <br>
```java
@Entity
public class Member {
  
  @Id @GeneratedValue
  @Column(name = "MEMBER_ID")
  private Long id;
  
  private String username;
  
  @ManyToOne                   
  @JoinColumn(name = "TEAM_ID")
  private Team team;
  
  //getter, setter
}
```

`팀 엔티티` <br>
```java
@Entity
public class Team {     
  
  @Id @GeneratedValue
  @Column(name = "TEAM_ID")
  private Long id;
  
  private String name;
  
  @OneToMany(mappedBy = "team")  //추가
  private List<Member> members = new ArrayList<Member>();
  
  //getter, setter
}
```

+ 양방향은 외래키가 있는 쪽이 연관관계의 주인이다.
> 일대다와 다대일 연관관계는 항상 다(N)에 외래키가 있다. <br> 여기서는 N쪽인 MEMBER 테이블이 외래키를 가지고 있으므로 Member.team이 연관관계의 주인이다. <br>
> JPA는 외래키를 관리할 때 연관관계의 주인만 사용한다. <br> `주인이 아닌 Team.members는 조회를 위한 JPQL이나 객체그래프를 탐색할 때 사용한다.`

+ 양방향 연관관계는 항상 서로를 참조해야 한다.
> 양방향 연관관계는 항상 서로 참조해야 한다. <br> 어느 한 쪽만 참조하면 양방향 연관관계가 성립하지 않는다. <br> 항상 서로 참조하게 하려면 연관관계 편의 메소드를 작성하는 것이 좋다.
> <br> 편의 메소드를 양쪽에 다 작성하면 무한루프에 빠지므로 주의하자. <br> 무한루프에 빠지지 않도록 검사하는 로직도 있다.



## 7. 일대다
엔티티를 하나 이상 참조할 수 있으므로 자바 컬렉션인 Collection, List, Set, Map 중에 하나를 사용해야 한다.

## 8. 일대다 단방향
![일대다 단방향](https://user-images.githubusercontent.com/57389368/186350662-8df26212-2eef-4eec-a774-714004119a3a.JPG) <br>

+ 일단 이 모델을 권장하지 않는다.
> DB 입장에서는 TEAM이랑  MEMBER에서 N쪽인 MEMBER가 외래키를 가져야 한다. <br> TEAM에 외래키가 있다면 TEAM을 계속 insert해야 하므로 TEAM이 1이 아닌 중복이 되버린다.

+ DB 입장에서는 TEAM이 아닌 MEMBER가 외래키 주인이다.
> Team에 'List members'에 members의 값을 바꿨을 때 뭔가 'TEAM_ID(FK)' 외래키를 업데이트 해줘야 한다. <br>
> 예: Team에서 'List members'가 연관관계 주인이며, 외래키는 MEMBER의 'TEAM_ID(FK)'에 있다.  <br> 'List members'를 추가/변경하려면 MEMBER의 TEAM_ID를 변경해줘야 한다.

`Member 엔티티` <br>
```java
@Entity
public class Member {
  
  @Id @GeneratedValue
  @Column(name = "MEMBER_ID")
  private Long id;
  
  private String username;
  
  //외래키를 매핑할 수 있는 참조 필드가 없다.
  
  //getter, setter
}
```

`Team 엔티티` <br>
```java
@Entity
public class Team {     
  
  @Id @GeneratedValue
  @Column(name = "TEAM_ID")
  private Long id;
  
  private String name;
  
  @OneToMany
  @JoinColumn(name = "TEAM_ID") //MEMBER 테이블의 TEAM_ID (FK)
  private List<Member> members = new ArrayList<Member>();
  
  //getter, setter
}
```

+  일대다 단방향 관계는 약간 특이하다.
+ `1` 팀 엔티티의 Team.members로 회원 테이블의 TEAM_ID 외래키를 관리한다.
+ `2` 보통 자신이 매핑한 테이블의 외래키를 관리하는데, 이 매핑은  반대쪽 테이블에 있는 외래키를 관리한다.
+ `3` 그럴 수밖에 없는 것이 일대다 관계에서 외래키는 항상 다쪽 테이블에 있다.
+ `4` 하지만 다 쪽인 Member 엔티티에는 외래키를 매핑할 수 있는 참조 필드가 없다.
+ `5` 대신에 반대쪽인 Team 엔티티에만 참조 필드인 members가 있다.\
+ `6` 따라서 반대편 테이블의 외래키를 관리하는 특이한 모습이 나타난다.

<br> <br>

+ 일대다 단방향 관계를 매핑할 때는 @JoinColumn을 명시해야 한다.
+ 그렇지 않으면 JPA는 연결 테이블을 중간에 두고 연관관계를 관리하는 조인 테이블 전략을 기본으로 사용해서 매핑해야 한다.
> 조인테이블은 나중에 자세히 알아보자.

### 일대다 단방향 매핑의 문제
```java
public void testSave() {
  
  Member member1 = new Member("member1");
  Member member2 = new Member("member2");
  
  Team team1 = new Team("team1");
  team1.getMembers().add(member1);
  team1.getMembers().add(member2);
  
  em.persist(member1);  //insert member1
  em.persist(member2);  //insert member2
  em.persist(team1);    //insert team1, update member1.fk, update member2.fk
  
  transaction.commit();
}
```  

` 결과창` <br>
```
insert into Member (MEMBER_ID, username) values (null, ?)
insert into Member (MEMBER_ID, username) values (null, ?)
insert into Team (TEAM_ID, name) values (null, ?)
update Member set Team_ID =? where MEMBER_ID=?
update Member set Team_ID =? where MEMBER_ID=?
```

`update Member 쿼리가 나간 이유는?` <br>
+ Member 엔티티는 Team 엔티티를 모른다.
+ 연관관계에 대한 정보는 Team 엔티티의 members가 관리한다.
+ 따라서 Member 엔티티를 저장할 때는 MEMBER 테이블의 TEAM_ID 외래키에 아무값도 저장되지 않는다.
+ 대신 Team 엔티티를 저장할 때 Team.members의 참조값을 확인해서 회원 테이블에 있는 TEAM_ID 외래키를 업데이트한다.

<br> <br>

### 일대다 단방향 정리
+ 일대다 단방향은 (1)쪽이 연관관계 주인이다.
+ 테이블 연관관계에서, 일대다 관계는 항상 (N)쪽이 외래키를 갖는다. (여기서 관계가 틀어진다.)
+ 객체 연관관계와 테이블 연관관계의 차이 때문에, 반대편 테이블의 외래키를 관리하는 특이한 구조다. (패러다임이 다른데, ORM이 억지로 해결하려는 것)
+ JoinColumn을 꼭 써야 한다. (JoinColumn 없이 실행하려면, 중간 테이블을 추가해야 한다.)

### 일대다 단방향의  단점
+ 엔티티가 관리하는 외래키가 다른 테이블에 있다. (엄청난 단점)
+ 연관관계 관리를 위해 추가로 update SQL을 실행한다.
+ `결론, 다대일 양방향 매핑을 사용하자.`

### 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자.
+ 일대다 단방향 매핑을 사용하면 엔티티를 매핑한 테이블이 아닌 다른 테이블의 외래키를 관리해야 한다.
+ 이것은 성능 문제도 있지만 관리도 부담스럽다.
+ 문제를 해결하는 좋은 방법은 다대일 양방향 매핑을 사용하는 것이다.
+ `다대일 양방향 매핑은 관리해야 하는 외래키가 본인 테이블에 있다.`
+ 따라서 일대다 단방향 매핑 같은 문제가 발생하지 않는다.

## 9. 일대다 양방향
+ `일대다 양방향 매핑은 존재하지 않는다.` 대신 다대일 양방향 매핑을 사용해야 한다.
> 일대다 양방향과 다대일 양방향은 사실 똑같은 말이다. 여기서는 왼쪽을 연관관계의 주인으로 가정해서 분류했다. <br> 예를 들어 다대일이면 (N)이 연관관계의 주인이다.

+ 양방향 매핑에서 @OneToMany는 연관관계의 주인이 될 수 없다.
+ `왜냐하면 RDB 특성상 일대다,다대일 관계는 항상 다 쪽에 외래키가 있다.`
+ 따라서 @OneToMany, @ManyToOne 둘 중에 연관관계의 주인은 항상 (N)쪽인 @ManyToOne을 사용한 곳이다.
+ 이런 이유로 @ManyToOne에는 mappedBy 속성이 없다.

<br><br>
+ 일대다 양방향 매핑이 완전히 불가능한 것은 아니다.
+ 일대다 단방향 매핑 반대편에 같은 외래키를 사용하는 다대일 단방향 매핑을 읽기 전용으로 하나 추가하면 된다.

<br><br><br><br>
![일대다 양방향](https://user-images.githubusercontent.com/57389368/186378116-8cd7c515-de92-4e6b-a753-f57a0f4a6687.JPG) <br>
+  Team에 'List members'가 연관관계 주인이다. (일대다의 1이므로)

<br><br>

### MEMBER의 TEAM_ID가 외래키를 관리하는 그림에서 "Member -> Team"하고 싶다면? <br>
`Member 엔티티` <br>
```java
@Entity
public class Member {
  
  @Id @GeneratedValue
  @Column(name = "MEMBER_ID")
  private Long id;
  
  private String username;
  
  //추가
  @ManyToOne
  @JoinColumn(name = "TEAM_ID", insertable = false, update = false)
  private Team team;
  
  //getter, setter
}
```

`Team 엔티티` <br>
```java
@Entity
public class Team {     
  
  @Id @GeneratedValue
  @Column(name = "TEAM_ID")
  private Long id;
  
  private String name;
  
  @OneToMany
  @JoinColumn(name = "TEAM_ID") //MEMBER 테이블의 TEAM_ID (FK)
  private List<Member> members = new ArrayList<Member>();
  
  //getter, setter
}
```

+ `일대다 단방향 매핑 반대편에 다대일 단방향 매핑을 추가했다.` (양방향처럼 보이도록 했다.)
+ 이때 일대다 단방향 매핑과 같은 TEAM_ID 외래키 컬럼을 매핑했다.
+ 이렇게 되면 둘 다 같은 키를 관리하므로 문제가 발생할 수 있다.
+ `따라서 반대편인 다대일 쪽은 insertable=false, updateable = false로 설정해서 읽기만 가능하게 했다.` 
+ 일대다 단방향 매핑이 가지는 단점을 그대로 가진다.
+ `결론, 다대일 양방향 매핑을 사용하자.`

## 10. 일대일
+ 양쪽이 서로 하나의 관계만 가진다.
+ 예: 회원은 하나의 사물함만 사용한다.
+ 주 테이블이나 대상 테이블 중에 외래 키 선택 가능하다.
> `주 테이블에 외래 키` <br>
> 외래키를 객체참조와 비슷하게 사용할 수 있어야 객체지향 개발자들이 선호한다. <br>
> 장점: 주 테이블이 외래키를 가지고 있으므로 주 테이블만 확인해도 대상 테이블과 연완관계가 있는지 확인가능하다. <br>
> `대상 테이블에 외래 키` <br>
> 전통적인 DB 개발자들이 선호한다. <br> 장점: 테이블 관계를 일대일에서 일대다로 변경할 때 테이블구조를 그대로 유지할 수 있다.

<br> <br>
### 예: 회원은 하나의 사물함만 사용한다.
+ `MEMBER가 주 테이블이다.`
+ `LOCKER는 대상 테이블이다.`

## 11. 주 테이블에 외래키를 둔 일대일 단방향

![일대일_ 주 테이블에 외래 키 단방향](https://user-images.githubusercontent.com/57389368/186384917-1911bc69-44b0-4b86-921c-7ecb02330a6c.JPG) <br>
+ `1` 회원당 하나의 사물함을 가진다.
+ `2` MEMBER입장에서 주 테이블, 대상 테이블 둘 중에 선택가능하다. (여기선 주 테이블 MEMBER에 외래키를 둠)

<br><br>
`Member` <br>
```java
@Entity
public class Member {
  @Id @GeneratedValue
  @Column(name = "MEMBER_ID")
  private Long id;
  
  private String username;
  
  @OneToOne
  @JoinColumn(name = "LOCKER_ID")
  private Locker locker;
  
  ...
}
```

`Locker` <br>
```java
@Entity
public class Locker {
  @Id @GeneratedValue
  @Column(name = "LOCKER_ID")
  private Long id;
  
  private String name;
}
```

+ 일대일 관계이므로 객체 매핑에 @OneToOne을 사용했고, DB에는 LOCKER_ID 외래키에 유니크 제약 조건(UNI)을 추가했다.
+ `참고로 이 관계는 다대일 단방향과 거의 비슷하다.`


## 12. 주 테이블에 외래키를 둔 일대일 양방향
![일대일_ 주 테이블에 외래 키 양방향](https://user-images.githubusercontent.com/57389368/186389567-3b2c7319-2fbc-47a7-a8f7-7ad1febf2436.JPG) <br>
+ 양방향 매핑을 하려면, 단순히 Locker에 'Member member'를 추가하면 된다.

<br><br>
`Member` <br>
```java
@Entity
public class Member {
  @Id @GeneratedValue
  @Column(name = "MEMBER_ID")
  private Long id;
  
  private String username;
  
  @OneToOne
  @JoinColumn(name = "LOCKER_ID")
  private Locker locker;
  
  ...
}
```

`Locker` <br>
```java
@Entity
public class Locker {
  @Id @GeneratedValue
  @Column(name = "LOCKER_ID")
  private Long id;
  
  private String name;
  
  //추가
  @OneToOne(mappedBy = "Locker")
  private Member member;
  
  ...
}
```

+ 양방향이므로 연관관계의 주인을 정해야 한다.
+ MEMBER 테이블이 외래키를 가지고 있으므로 Member엔티티에 있는 Member.locker가 연관관계의 주인이다.
+ 따라서 반대 매핑인 사물함의 Locker.member는 mappedBy로 둔다.
+ `다대일 단방향 매핑과 유사하다.`

## 13. 대상 테이블에 외래키를 둔 일대일 단방향
![일대일_ 대상 테이블에 외래 키 단방향](https://user-images.githubusercontent.com/57389368/186391929-6ed9d7f0-37dd-4fe1-9a3d-9ddc16e4a2c1.JPG) <br>

+ `대상 테이블에 외래키가 있는 일대일 단방향 관계는 JPA에서 지원하지 않는다.`
+ 이런 모양의 매핑을 하지 못한다.
+ 이때는 단방향 관계를 Locker에서 Member 방향으로 수정하거나, 양방향 관계로 만들고 Locker를 연관관계의 주인으로 설정해야 한다.

> `1` Member의 'Locker locker'가 연관관계의 주인을 하고 싶은데, <br>
> `2` 외래키가 LOCKER 테이블에 LOCKER_ID(PK)가 있다. (마치 일대다 단방향 같다.) <br>
> `3` 그래서 Member의 locker로 LOCKER 테이블의 MEMBER_ID(FK)로 관리 못한다.

> 참고로, JPA 2.0부터 일대다 단방향 관계에서 대상 테이블에 외래키가 있는 매핑을 허용했다. <br> 하지만 일대일 단방향은 이런 매핑을 허용하지 않는다.

## 14. 대상 테이블에 외래키를 둔 일대일 양방향
![일대일_ 대상 테이블에 외래 키 양방향](https://user-images.githubusercontent.com/57389368/186394738-ed98c4a8-75e6-419a-9de2-a532844262bb.JPG) <br>
+ `1` LOCKER(대상 테이블)에 외래키(MEMBER_ID, Fk,UNI)를 둔다.
+ `2` 주 엔티티인 Member 엔티티 대신에, 대상 엔티티인 Locker를 연관관계의 주인으로 만든다.
+ `3` LOCKER 테이블의 외래키를 직접 관리하도록 한다.
+ `사실 일대일 주 테이블에 외래 키 양방향과 매핑 방법은 같음`

### 참고
`프록시를 사용할 때 외래키를 직접 관리하지 않는 일대일 관계는 지연로딩으로 설정해도 즉시로딩된다.` <br>
> 예: Locker.member는 지연로딩할 수 있지만, Member.locker는 지연로딩으로 설정해도 즉시로딩된다. <br> 이것은 프록시의 한계 때문에 발생하는 문제인데 프록시 대신에 bytecode instrumentation을 사용하면 해결할 수 있다. <br>  참고사이트: https://developer.jboss.org/docs/DOC-13960 <br> 프록시와 지연로딩 편에서 자세히 알아보자.


### 일대일 매핑의 설계
+ `일대일 매핑에서 대상 테이블에 외래키를 두고 싶으면, 양방향 매핑을 한다.`
+ `주 엔티티가 아닌, 대상 엔티티를 연관관계의 주인으로 만든다.`
+ 대상 엔티티의 외래키를 직접 관리하도록 한다.

## 15. 일대일 정리편
### 주 테이블에 외래 키
+ 주 객체가 대상 객체의 참조를 가지는 것 처럼, 주 테이블에 외래 키를 두고 대상 테이블을 찾음
+ 객체지향 개발자 선호한다.
+ JPA 매핑 편리하다.
+ 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
+ 단점: 값이 없으면 외래 키에 null 허용 (DBA 입장에서는 치명적임)
+ 주 테이블에 외래키를 둔다.
 
### 대상 테이블에 외래 키
+ 대상 테이블에 외래 키가 존재
+ 전통적인 데이터베이스 개발자 선호한다.
+ 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지된다. (null값 안 넣어도 된다.)
+ 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨(프록시는 뒤에서 설명) 

> JPA에 프록시 객체를 만들려면, 'Locker locker'에 값이 있는지/없는지 알아야 한다. <br> 그래서 일대일 - 주 테이블에 외래키를 두면 된다. <br>
> JPA입장에서는 Member를 로딩할 때, 값이 있으면 넣어주고, 없으면 null을 허용한다.
