이 장부터 다룰 내용은 다음과 같다. 
+ 프록시, 즉시로딩, 지연로딩

> 객체는 객체 그래프로 연관된 객체들을 탐색한다. <br> 그런데 객체가 DB에 저장되어 있으므로 연관된 객체를 마음껏 탐색하기는 어렵다. 

> JPA 구현체들은 이 문제를 해결하려고 프록시라는 기술을 사용한다. <br> 프록시를 사용하면 연관된 객체를 처음부터 DB에서 조회하는 것이 아니라, <br>
> 실제 사용하는 시점에 DB에서 조회할 수 있다. <br> 하지만, 자주 함께 사용하는 객체들을 조인을 사용해서 함께 조회하는 것이 효과적이다.

<br>

+ 영속성 전이와 고아 객체
> JPA는 연관된 객체를 함께 저장하거나, 함께 삭제할 수 있는 영속성 전이와 고아 객체 제거 기능을 제공한다.

[1. 프록시](#1-프록시) <br>
[2. 프록시 기초](#2-프록시-기초) <br>

## 프록시 
다음과 엔티티를 조회할 때, 연관된 엔티티들이 필요 없는 경우도 많다.

`회원 엔티티` <br>
```java
@Entity 
public class Member {
  private String username;
  
  @ManyToOne
  private Team team;
  
  //geter
}
```

`팀 엔티티` <br>
```java
@Entity
public class Team {
  private String name;
  
  //getter
}
```

#### 예제1 : 회원과 팀 정보를 출력하는 비즈니스 로직
+ 해당 메소드 printUserAndTeam()은 memberId로 회원 엔티티를 찾아서 연관된 팀의 이름도 출력한다.
```java
public void printUserAndTeam(String memberId) {
  Member member = em.find(Member.class, memberId);
  Team team = member.getTeam();
  System.out.println("회원 이름: " + member.getUsername());
  System.out.println("소속팀 : " + team.getName());
}
```

#### 예제2 :회원 정보만 출력하는 비즈니스 로직
+ 해당 메소드 printUser()은 회원 엔티티만 출력하는 데 사용한다. (연관 엔티티X)
+ 이 경우 회원 엔티티를 조회할 때 회원과 연관된 팀 엔티티까지 DB에서 함께 조회되므로, 효율적이지 않다.
```java
public String printUser(String memberId) {
  Member member = em.find(Member.class, memberId);
  System.out.println("회원이름: " + member.getUsername());
}
```

### 지연 로딩
+ JPA는 이런 문제를 해결하려고 엔티티가 실제 사용될 때까지 DB 조회를 지연하는 방법을 제공한다.
+ team.getName()처럼 엔티티의 값을 `실제 사용하는 시점`에, DB에서 팀 엔티티에 필요한 데이터 를 조회하는 것이다. 
+  `지연로딩을 사용하려면, 실제 엔티티 객체 대신에 DB 조회를 지연할 수 있는 가짜 객체가 필요`한데, 이것을 프록시라고 한다.

## 2. 프록시 기초
+ JPA에서 식별자로 엔티티 하나를 조회할 때는 EntityManager.find()를 사용한다.
> Member member = em.find(Member.class, "member1"); <br> `find()메소드는 영속성 컨텍스트에 엔티티가 없으면 DB에서 조회한다.`

+ 엔티티를 실제 사용하는 시점까지 DB조회를 미루고 싶을 때는  EntitiyManager.getReference() 메소드를 사용하면 된다.
> Member member = em.getReference(Member.class, "member1");  <br> `getReference() 메소드는 DB에서 조회하지 않고 실제 엔티티 객체도 생성하지 않는다.` <br>
> `대신에 DB 접근을 위임한 프록시 객체를 반환한다.`

### 프록시의 특징
![프록시 기초](https://user-images.githubusercontent.com/57389368/188454166-a56b69e0-bfff-486c-88cf-2ed7a54dd060.JPG)
+ 프록시 클래스는 실제 클래스를 상속 받아서 만들어진다. (그래서 겉 모양이 같다.)
+ 따라서, 사용하는 입장에서는 '진짜 객체인지' '가짜 객체인지' 구분하지 않고 사용하면 된다.

<br>

![프록시 기초2](https://user-images.githubusercontent.com/57389368/188454661-7ef810f1-d680-4f9a-80d2-5dec09eed6e2.JPG) <br>
+ 프록시 객체는 실제 객체에 대한 참조를 보관한다.
+ 그리고 프록시 객체는 실제 객체에 대한 참조(target)를 보관한다.
+ 프록시 객체의 메소드를 호출하면, 프록시 객체는 실제 객체의 메소드를 호출한다.

<br> <br>

### 프록시 객체의 초기화
+ 프록시 객체의 초기화 :프록시 객체는 member.getName()처럼 실제 사용할 때, DB를 조회해서 실제 엔티티 객체를 생성한다.

`프록시 초기화 예제` <br>
```java
//MemberProxy 반환
Member member = em.getReference(Member.class, "id1");
member.getName(); 
```

`프록시 클래스 예상 코드` <br>
```java
class MemberProxy extends Member {
  Member target = null; //1. 실제 엔티티 참조
  
  public String getName() {
      if (target == null) {
          //2. 초기화 요청
          //3. DB 조회
          //4. 실제 엔티티 생성 및 참조 보관
      }
      
      //5. target.getName();
      return target.getName();
    }
 }
 ```
 
 <br>
 
#### 프록시의 초기화 과정 
![프록시 초기화](https://user-images.githubusercontent.com/57389368/188457131-17682d48-bbec-4c46-900c-6fd23def8af1.JPG) <br>
+ `1` 프록시 객체에 member.getName()을 호출해서 실제 데이터를 조회한다.
+ `2` 프록시 객체는 실제 엔티티가 생성되어 있지 않으면, 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 초기화라고 한다.
+ `3` 영속성 컨텍스트는 DB를 조회해서 실제 엔티티 객체를 생성한다.
+ `4` 프록시 객체는 생성된 실제 엔티티 객체의 참조를 Member target 멤버변수에 보관한다.
+ `5` 프록시 객체는 실제 엔티티 객체의 getName()을 호출해서 결과를 반환한다.

<br>

### 프록시 특징
+ 프록시 객체는 처음 사용할 때, 한 번만 초기화된다.
+ 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. <br> 프록시 객체 초기화되면, 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.
+ 프록시 객체는 원본 엔티티를 상속받은 객체이므로, 타입 체크 시에 주의해서 사용해야 한다.
+ 영속성 컨텍스트에 찾는 엔티티가 이미 있으면, DB 조회 필요가 없으므로, em.getReference()를 호출해도 된다.
+ 초기화는 영속성 컨텍스트의 도움이 필요하다. <br> 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태의 프록시를 초기화하면 문제가 발생한다.

#### 준영속 상태와 초기화 <br>
> `준영속 상태의 프록시를 초기화하면 LazyInitializeationException 예외를 발생시킨다.` <br> 
> 준영속 상태는 영속성 컨텍스트가 없으므로, 실제 엔티티를 조회할 수 없어 예외가 발생한다.

```java
//MemberProxy 반환
Member member = em.getReference(Member.class, "id1");
transaction.commit();
em.close(); //영속성 컨텍스트 종료 --> member는 준영속 상태가 됨.

member.getName(); //준영속 상태 초기화 시도,  LazyInitializationException 예외 발생
```
      
