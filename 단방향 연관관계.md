## 📌 목차
+ 객체의 참조와 테이블의 외래 키를 매핑하는 것이 이 장의 목표다.

<br> <br> 
------
엔티티들은 대부분 다른 엔티티와 연관관계가 있다. <br>
+ `주문-상품의 관계` : 어떤 상품을 주문했다.
+ `상품-카테고리,재고의 관계` : A카테고리의 상품으로 N개 남아있다.
+ 그런데 객체와 테이블은 완전히 다른 특징을 가진다.
```
객체는 참조(주소)를 사용해서 관계를 맺고 
테이블은 외래키를 사용해서 관계를 맺는다.
```

### 1. 객체의 참조와 테이블의 외래 키를 매핑하는 것이 이 장의 목표다.
`객체 관계 매핑에서 가장 어려운 부분이 바로 객체 연관관계와 테이블 연관관계를 매핑하는 일이다.`

+ 방향
```
단방향 관계 : 한쪽만 참조하는 것
양방향 관계: 양쪽 모두 서로 참조하는 것
```

+ 다중성
```
N:1, 1:N, 1:1, N:M 
예를 들어 
회원과 팀이 관계가 있을 때 여러 회원은 한 팀에 속하므로, 회원과 팀은 N:1 관계다.
(반대로) 한 팀에 여러 회원이 소속될 수 있으므로, 팀과 회원은 1:N 관계다.
```

+ 연관관계 주인
```
객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.
```

### 2. 다대일 단방향 관계
+ 회원과 팀이 있다.
+ 회원은 하나의 팀에만 소속될 수 있다.
+ 회원과 팀은 다대일 관계다.

![단방향 연관관계1](https://user-images.githubusercontent.com/57389368/162254354-2bf8fa78-bb98-4951-a44f-52a4d6b7f505.JPG)
#### 객체 연관관계
+ 회원 객체는 Member.team필드(멤버변수)로 팀 객체와 연관관계를 맺는다.
+ 회원 객체와 팀 객체는 단방향 관계다.
+ 회원은 Member.team 필드를 통해서 팀을 알 수 있다.
+ 반대로 팀은 회원을 알 수 없다.

> member -> team 조회는 가능하다, member.getTeam()  <br> 반대 방향인 team->member 접근 불가능 

#### 테이블 연관관계
+ 회원 테이블은 TEAM_ID 외래키로 팀 테이블과 연관관계를 맺는다.
+ 회원 테이블과 팀 테이블은 양방향 관계다.
+ 회원 테이블의 TEAM_ID 외래키를 통해서 회원과 팀을 조인할 수 있다.
+ 반대로 팀과 회원도 조인할 수 있다.
> 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다.

+ `MEMBER 테이블의 TEAM_ID 외래키 하나로 MEMBER JOIN TEAM과 TEAM JOIN MEMBER 둘 다 가능하다.`
```
# 회원과 팀을 조인하는 SQL
SELECT  
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
```

```
# (반대로) 팀과 회원을 조인하는SQL
SELECT *
FROM TEAM T
JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID
```

#### 객체 연관관계와 테이블 연관관계의 가장 큰 차이
+ 참조를 통한 연관관계는 언제나 단방향이다.
+ 객체간에 연관관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야 한다.
> 결국 연관관계를 하나 더 만들어야 한다. <br> 이렇게 양쪽에서 서로 참조하는 것을 양방향 연관관계라 한다. 

+ `하지만 양쪽에 필드를 추가해서 참조를 보관하면, 서로 다른 단방향 관계 2개를 만든 셈이다.`
> 이렇게 양쪽에서 서로 참조하는 것을 양방향 연관관계라 한다. <br> 하지만 정확히 이야기하면 이것은 양방향 관계가 아니라 서로 다른 단방향 관계 2개다. <br> 반면에 테이블은 외래키 하나로 양방향으로 조인할 수 있다.

```java
# 단방향 연관관계
class A {
    B b;
}
class B {}
```

```java
#양방향 연관관계
class A {
     B b;

}
class B {
     A a;
}
```

#### 객체 연관관계 vs 테이블 연관관계
+ `객체는 참조(주소)로 연관관계를 맺는다.`
+ `테이블은 외래키로 연관관계를 맺는다.`
> 이 둘은 비슷해 보이지만 매우 다른 특징을 가진다. <br> 연관된 데이터를 조회할 때 객체는 참조를 사용한다. (a.getB().getC()) <br> 테이블은 조인을 사용한다. (JOIN)

+ `참조를 사용하는 객체의 연관관계는 단방향이다.` A->B (a.b)
+ `외래키를 사용하는 테이블의 연관관계는 양방향이다.` A JOIN B / B JOIN A
+ `객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.` A->B(a.b) B->A(b.a)  

<br> <br> 
------
#### 순수한 객체 연관관계
순수하게 객체만 사용한 연관관계를 살펴보자. JPA를 사용하지 않은 순수한 회원과 팀 클래스의 코드다.
```java
public class Member {
    private String id;
    private String username;
    
    private Team team; //팀의 참조를 보관한다.
    
    public void setTeam(Team team) {
        this.team = team;
    }
    
    //getter, setter
}
```

```java
public Team {
    private String id;
    private String name;

   //getter setter
}
```

